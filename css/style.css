@charset "UTF-8";
/*Acá creamos un mixin que será un clearfix, dado que al estar los div con float hace que colapse el 
heigth a 0px y se encimen unos a otros. Con este clearfix por medio del pseudo-element ::after creamos 
un elemento por detrás que mantiene la altura.
Luego agregamos este mixin con @include*/
/********ANIMATIÓN del Título del header*************/
@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
    /*igual a -100px*/ }
  80% {
    transform: translateX(1rem);
    /*igual a 10px*/ }
  100% {
    opacity: 1;
    transform: translateX(0); } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
    /*igual a 100px*/ }
  80% {
    transform: translateX(-1rem);
    /*igual a -10px*/ }
  100% {
    opacity: 1;
    transform: translateX(0); } }

/*
  - La animación podemos hacerla con Transition y luego hoover. Pero en este caso vemos otro modo 
  con @keyframe, se le pone un nombre (identifier) y luego se especifica 0% (cuando comienza) 100% (cuando
  termina) desde donde hasta donde va la animación. 
  -En 0 ponemos opacity 0 para que el elemento no se vea, y en 100 ponemos opacity 1 para que sea visible.
  -Transform:translatex, es que se mueva en dirección el eje x (horizontalmente), si es número negativo se
  mueve de derecha a izq y si es positivo de izq a der. 
  -Ahora vamos al selector (en nuestro caso: .heading-primary-main y sub) que queremos animar y 
  colocamos animation-name y animation-duration
  - Otra properties de Animation es Delay:..s, para que la animación empiece después de x tiempo. Otra
  animation-iteration-count:nº, por ejemplo si ponemos 3, se repite 3 veces....etc
  - A veces la animación, sin que se sepa bien porqué, rebota (en mi caso no hace eso el browser), 
  para evitarlo en .heading-primary usamos backface-visibility:hidden; 
  es un truco no se sabe porqué funciona. 
  */
/*Animación del boton*/
@keyframes moveInButton {
  0% {
    opacity: 0;
    transform: translateY(3rem);
    /*igual a 30px*/ }
  100% {
    opacity: 1;
    transform: translateX(0); } }

/***********BASIC RESET******************/
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
  /* box-sizing: border-box; esto lo vamos a colocar en el body para aprovechar el inherit keyword 
  en nuestra página web y es una mejor práctica poner acá inherit y en el body border-box*/ }

/*
- Arriba lo que hicimos fue usar el "univesal selector" para resetear los margenes y padding
que por defecto tendríamos según los browsers. Es un basic reset. Agregamos tb pseudo-classes.
- Box sizing es útil a la hora de calcular todo lo que es el tamaña de los elementos y querer
agregarle paddings y margins...etc.
*/
html {
  font-size: 62.5%; }

/* es un base element porque define lo que un rem debe ser - 
por eso no lo ponemos en la carpeta de typography
- root element. Así todas nuestras unidades rem hacen referencia a este root y se multiplicarían por 10
- No vamos a definir el font-size en px, porque eso impide al usuario modificar luego el tamaño de la
fuente con el browser. Lo que queremos es definirlo en porcentaje.
Si ponemos font-size 100% equivaldría a 16px, porque ese es el default value de los font-size.
Como queremos que sean 10px hacemos regla de tres simples 100*10/16 = 62.5%
Ahora el user va a poder zoom in and zoom out no solo el font-size sino tb la página en sí
- Nota: el viejo Internet expolorer no soporta rems
*/
body {
  box-sizing: border-box; }

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* font-size: 16px; antes de crear el root teníamos este font-size 
    que ahora sacamos para poner las demás unidades en rem*/
  line-height: 1.7;
  color: #777;
  padding: 3rem;
  /*antes habíamos puesto 30px. Ahora son 3rem que multiplicado por 10px del html es igual a 30px*/ }

/*
  - font-family, es de google fonts, cuyo link hay que agregar en el código html, head section.
  - font-weight, 400 es igual a normal (default), y 700 igual a bold
  - line-height, si ponemos un número significa que es lo que se va a multiplicar del font size
  (se pueden usar px, rem, %...etc)
  - Agregamos un padding en el body, lo que hace que todos los elementos de nuestra página ahora
  tengan el mismo, salvo lo reescribamos.
  */
.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  /*es para que funcione mejor la animación*/
  margin-bottom: 6rem;
  /*es para que el button se separe del heading*/
  /*
    -usamos display block para que cada span esté uno debajo del otro, de lo contrario by default
    son un inline element y estarían uno al lado del otro
    -el font-weight lo especificamos porque por defecto h1 tiene bold, y se sobreescribe al que
    ya habíamos puesto en el body por estar el h1 luego del body. Así que volvemos a poner 400px
    para que no sea bold.
    - Aniation property, en el heading-primary-sub usé el shorthand (de animation-name, animation-duration,
    animation-timing-function. 
    */ }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    /* igual a 60px*/
    font-weight: 400;
    letter-spacing: 3.5rem;
    /*igual a 35px*/
    animation-name: moveInLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out; }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    /*igual a 20px*/
    font-weight: 700;
    letter-spacing: 1.74rem;
    /*igual a 17.4px*/
    animation: moveInRight 1s ease-out; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700;
  letter-spacing: 2px;
  /*GRADIENTE PARA LAS LETRAS. Se le pone un background-image con gradient*/
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  background-clip: text;
  -webkit-background-clip: text;
  /*Esto hace que el background-image gradient solo se pegue al texto.
  Hay que poner dos veces el background-clip para que el navegador lo agarre. 
  */
  color: transparent;
  /*el color del texto lo ponemos en transparente para solo ver el background-image gradient.
  Si no lo ponemos transparente veremos el texto en su color gris, pues se sienta sobre el 
  background-image con gradient*/
  display: inline-block;
  /*esto es para que el color solo ocupe el espacio de la tipografía. Porque el h2 sería un block
  element y ocuparía todo el ancho de la pantalla, y el gradient se vería en todo el ancho*/
  transition: all 0.2s; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.315); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  text-align: center; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem; }

.u-margin-bottom-medium {
  margin-bottom: 4rem; }

.u-margin-bottom-big {
  margin-bottom: 8rem; }

.u-margin-top-big {
  margin-top: 8rem; }

.u-margin-top-huge {
  margin-top: 10rem; }

.bg-video {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  width: 100%;
  /*Así centramos el video para que quede como background. La position es absolute y la del parent 
  es relative (ver en _home .section-stories*/
  z-index: -1;
  opacity: 0.15;
  overflow: hidden; }
  .bg-video_content {
    height: 100%;
    width: 100%;
    object-fit: cover; }

/***********BUTTON************/
.btn {
  /*acá separo los selectors con comas, y tengo que poner primero el simple selector
    y luego los seudo-class
    - Acá vamos a hacer una animación más simple con Transition (en vez de con @keyframe). 
    Transition es el shorthand. "all" significa que queremos animar todas las propiedades de arriba, 
    usamos esto cuando no estamos seguros de cual animar o no queremos escribir todas las propiedades. 
    */
  /*
    - btn con seudo-class :link (es para darle estilo a los unvisited links) y :visited.
    - btn con seudo-class :hover (cuando nos posicionamos encima con el mouse), :active (cuando hagamos
    click sobre el botón)
    - transform:translateY, se moverá de arriba a abajo. Número negativo hace que vaya hacia arriba. 
    */
  /*****ANIMACION con seudo-element ::******/
  /*
  Animation-fill-mode hace que se mantenga en opacity:0 y se translate 30px como especificamos en el
  @keyframe recién cuando pase el tiempo del delay*/ }
  .btn, .btn:link, .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    /*igual a 15px y 40px*/
    display: inline-block;
    border-radius: 10rem;
    /*igual a 100px*/
    transition: all 0.2s;
    position: relative;
    /*esto es para la animación con seudo-element*/
    font-size: 1.6rem;
    /*es igual a 16px*/ }
  .btn:hover {
    transform: translateY(-0.3rem);
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.4);
    /*
    Con esto hacemos que cuando hagamos hover aparezca el btn::after que especificamos arriba y de agrande
    en 1.5 veces su tamaño y que se ponga transparente (opacity)*/ }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0; }
  .btn:active {
    transform: translateY(-0.1rem);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.4); }
  .btn--white {
    background-color: #fff;
    color: #777;
    /*
    - La idea es crear otro botón igual pero que esté por detrás, por eso usamos este seudo-element
    - Siempre en los seudo-element tenemos que poner "content" aunque despues lo dejemos vacío y el display
    - display inline-block porque así tb es el display del btn.
    - heigth y width es el 100% del tamaño del btn, que sería como su parent.
    - Positioning absolute tiene que tener un reference, en nuestro caso no queremos que sea el header ni el
    body, sino el btn, entonces es ahí donde le pondremos positon:relative
    - z-indez negativo es para que este botón se vaya atrás
    */ }
    .btn--white::after {
      background-color: #fff; }
  .btn--green {
    background-color: #55c57a;
    color: #fff; }
    .btn--green::after {
      background-color: #55c57a; }
  .btn::after {
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    /*igual a 100px*/
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all 0.4s; }
  .btn--animated {
    animation: moveInButton 0.5s ease-out;
    animation-delay: 0.75s;
    animation-fill-mode: backwards; }

.btn-text:link, .btn-text:visited {
  font-size: 1.6rem;
  color: #55c57a;
  display: inline-block;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 3px;
  transition: all 0.2s; }

.btn-text:hover {
  background-color: #55c57a;
  color: #fff;
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.4);
  transform: translateY(-2px); }

.btn-text:active {
  box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.4);
  transform: translateY(0); }

.card {
  perspective: 150rem;
  -moz-perspective: 150rem;
  /*hace que la tarjeta tenga un efecto de rotate más lindo. Si ponemos pocos rem veremos que el efecto
  es más exagerado. Hay que ir probando hasta ver que se vea lindo. Acá con 150rem se ve bien, menos
  ya se ve feo*/
  position: relative;
  height: 54rem;
  /*sería igual a .card:hover .card_side--front {}, lo que implica que cuando hagamos hover sobre la card 
  entonces se transforme el card_side--front*/ }
  .card_side {
    height: 54rem;
    transition: all 0.8s ease;
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    backface-visibility: hidden;
    border-radius: 3px;
    overflow: hidden;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.15); }
    .card_side--front {
      background-color: #fff; }
    .card_side--back {
      transform: rotateY(180deg); }
      .card_side--back-1 {
        background-image: linear-gradient(to right bottom, #ffb900, #ff7730); }
      .card_side--back-2 {
        background-image: linear-gradient(to right bottom, #7ed56f, #28b485); }
      .card_side--back-3 {
        background-image: linear-gradient(to right bottom, #2998ff, #5643fa); }
  .card:hover .card_side--front {
    transform: rotateY(-180deg); }
  .card:hover .card_side--back {
    transform: rotateY(0deg); }
  .card_picture {
    background-size: cover;
    height: 23rem;
    background-blend-mode: screen;
    /*esto va a compaginar las dos imágenes, gradient y jpg. 
    No funciona en todos los browsers*/
    -webkir-clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    clip-path: polygon(0 0, 100% 0, 100% 85%, 0 100%);
    border-top-left-radius: 3px;
    border-top-right-radius: 3px; }
    .card_picture--1 {
      background-image: linear-gradient(to right bottom, #ffb900, #ff7730), url(../img/nat-5.jpg); }
    .card_picture--2 {
      background-image: linear-gradient(to right bottom, #7ed56f, #28b485), url(../img/nat-6.jpg); }
    .card_picture--3 {
      background-image: linear-gradient(to right bottom, #2998ff, #5643fa), url(../img/nat-7.jpg); }
  .card_heading {
    font-size: 2.8rem;
    font-weight: 300;
    text-align: right;
    text-transform: uppercase;
    color: #fff;
    position: absolute;
    top: 12rem;
    right: 2rem;
    width: 75%; }
  .card_heading--span {
    padding: 1rem 1.5rem;
    -webkit-box-decoration-break: clone;
    box-decoration-break: clone;
    /*esta propiedad aplica igual padding a todas las cajas. Ver en inspeccionar que si lo sacamos el
    heading se desalinea*/ }
    .card_heading--span-1 {
      background-image: linear-gradient(to right bottom, rgba(255, 185, 0, 0.85), rgba(255, 119, 48, 0.85)); }
    .card_heading--span-2 {
      background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.85), rgba(40, 180, 133, 0.85)); }
    .card_heading--span-3 {
      background-image: linear-gradient(to right bottom, rgba(41, 152, 255, 0.85), rgba(86, 67, 250, 0.85)); }
  .card_details {
    padding: 3rem; }
    .card_details ul {
      list-style: none;
      width: 80%;
      margin: 0 auto; }
      .card_details ul li {
        text-align: center;
        font-size: 1.5rem;
        padding: 1rem; }
        .card_details ul li:not(:last-child) {
          border-bottom: 1px solid #eee; }
  .card_cta {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    text-align: center; }
  .card_price-box {
    text-align: center;
    color: #fff;
    margin-bottom: 8rem; }
  .card_price-only {
    font-size: 1.4rem;
    text-transform: uppercase; }
  .card_price-value {
    font-size: 6rem;
    font-weight: 100; }

.composition {
  position: relative;
  /*esto es para que cuando hacemos hover sobre una foto las otras se achiquen
sería igual a - composition:hover composition_photo:not(:hover) - es decir que cuando hagamos hover
en el composition que seleccione las composition_photos menos sobre la que estoy haciendo hover*/ }
  .composition_photo {
    width: 55%;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    border-radius: 2px;
    position: absolute;
    z-index: 10;
    transition: all 0.2s;
    outline-offset: 2rem; }
    .composition_photo--p1 {
      left: 0;
      top: -2rem; }
    .composition_photo--p2 {
      right: 0;
      top: 2rem; }
    .composition_photo--p3 {
      left: 20%;
      top: 10rem; }
    .composition_photo:hover {
      outline: 1.5rem solid #55c57a;
      transform: scale(1.05);
      box-shadow: 0 2.5rem 4rem rgba(0, 0, 0, 0.5);
      z-index: 20; }
  .composition:hover .composition_photo:not(:hover) {
    transform: scale(0.95) translateY(-0.5rem); }

.feature-box {
  background-color: rgba(255, 255, 255, 0.8);
  font-size: 1.5rem;
  padding: 2.5rem;
  text-align: center;
  border-radius: 3px;
  box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.233);
  transition: transform 0.3s; }
  .feature-box_icon {
    font-size: 6rem;
    margin-bottom: 0.5rem;
    background-image: linear-gradient(to right, #7ed56f, #28b485);
    background-clip: text;
    -webkit-background-clip: text;
    /*Esto hace que el background-image gradient solo se pegue al texto.
      Hay que poner dos veces el background-clip para que el navegador lo agarre. 
      */
    color: transparent;
    /*el color del texto lo ponemos en transparente para solo ver el background-image gradient.
      Si no lo ponemos transparente veremos el texto en su color gris, pues se sienta sobre el 
      background-image con gradient*/
    display: inline-block;
    /*esto es para que el color solo ocupe el espacio de la tipografía. Porque el h2 sería un block
      element y ocuparía todo el ancho de la pantalla, y el gradient se vería en todo el ancho*/ }
  .feature-box:hover {
    transform: translateY(-1.5rem) scale(1.03); }

.story {
  width: 75%;
  margin: 0 auto;
  box-shadow: 0 3rem 6rem rgba(0, 0, 0, 0.2);
  background-color: rgba(255, 255, 255, 0.6);
  /*para que sea medio transparente el background.No usamos
  opacity porque sino todo el contenido se volvería medio transparente*/
  border-radius: 3px;
  padding: 6rem;
  padding-left: 9rem;
  font-size: 1.6rem;
  transform: skewX(-12deg);
  /* el translate es para dar más espacio a la izq.entre la img y el texto. El skew es para enderezar
  la imagen ya que el rectángulo blanco tiene skew para deformarse -12deg*/
  position: relative; }
  .story_shape {
    height: 15rem;
    width: 15rem;
    float: left;
    -webkit-shape-outside: circle(50% at 50% 50%);
    shape-outside: circle(50% at 50% 50%);
    /*para que el texto envuelva circularmente la imagen. Para que funcione este shape-outside debemos 
    definir el float, height y width*/
    -webkit-clip-path: circle(50% at 50% 50%);
    clip-path: circle(50% at 50% 50%);
    transform: translateX(-3rem) skewX(12deg); }
  .story_img {
    height: 100%;
    transform: translateX(-4rem) scale(1.4);
    /*translate para que la chica de la img quede en el centro. Scale para la animación del hover
    se haga más chiquita la imagen*/
    transition: all 0.5s;
    backface-visibility: hidden; }
  .story_text {
    transform: skewX(12deg); }
  .story_caption {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, 20%);
    color: #fff;
    text-transform: uppercase;
    font-size: 1.7rem;
    text-align: center;
    opacity: 0;
    transition: all 0.5s;
    backface-visibility: hidden; }
  .story:hover .story_caption {
    opacity: 1;
    transform: translate(-50%, -50%); }
  .story:hover .story_img {
    transform: translateX(-4rem) scale(1);
    filter: blur(3px) brightness(80%); }

.row {
  max-width: 114rem;
  margin: 0 6rem; }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row::after {
    content: "";
    display: table;
    clear: both; }
  .row [class^="col-"] {
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - 2 * 6rem) / 3); }
  .row .col-1-of-4 {
    width: calc((100% - 3 * 6rem) / 4); }
  .row .col-2-of-3 {
    width: calc( 2 * ((100% - 2 * 6rem) / 3) + 6rem); }
  .row .col-2-of-4 {
    width: calc( 2 * ((100% - 3 * 6rem) / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc( 3 * ((100% - 3 * 6rem) / 4) + 2 * 6rem); }

/***************HEADER*****************/
.header {
  height: 95vh;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  -webkit-clip-path: polygon(0% 0%, 100% 0%, 100% 75vh, 0% 100%);
  clip-path: polygon(0% 0%, 100% 0%, 100% 75vh, 0% 100%);
  position: relative;
  /*
  -El header tiene una altura según el view port - no del 100% sino del 95%, para que siempre
  guarde esa dimensión.
  -Tiene una background image, y le ponemos antes de la url el linear gradient para que tenga
  como una veladura por encima. La dirección del gradient es de right to bottom y tiene dos 
  colores, de más claro a más oscuro. 
  - Cover, hace que siempre la imagen complete el contenedor. 
  - background-position, en nuestro caso pusimos top, hace que cuando agrandemos o achiquemos
  la página siempre se vea la parte de arriba de la imagen.
  - clip-path, me sirve para hacer figuras con los contenedores, imágenes.
  Por eso vemos el corte que tiene la imágen en el header. 
  La página https://bennettfeely.com/clippy/ te calcula cada lado para formar distintas figuras.
  - En CSS no podemos poner un hexagesimal color y después un opacity, sino rgba. Pero en SASS 
  sí. Entonces ponemos rgba y dentro nuestra variable más el grado de opacity.
  */
  /*es el div que contiene el logo.
    - Acá la position es absolute. Pero si vemos en el header class su position es relative. Esto
    hace un juego entre ambos elementos. Header es el parent del logo-box, y siendo su position
    relative ahora el absolute position del child en en relación a él y no al body. Ver esta
    página mejor explicado  
    https://css-tricks.com/absolute-positioning-inside-relative-positioning/
    */
  /*
    Sólo hace falta especificar el height y no el width, este lo pone el browser 
    */
  /*
    - Usamos transform:translate porque el positioning top y left lo mide desde los bordes
    del div y no hace que quede centrado, mientras que transform:translate mueve el div desde 
    el mismo, no desde su borde, es así que termina centrándose. Tb hace que sea responsive,
    y se mueva según el tamaño del browser.
    */ }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    /*antes pusimos 40px. Ahora es 4 por 10px del html root element igual 40px*/
    left: 4rem;
    /*lo mismo*/ }
  .header__logo {
    height: 3.5rem;
    /* igual 35px*/ }
  .header__text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    /*es para alinear el button*/ }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  margin-top: -20vh; }

/*ponemos 25rem porque si vemos el header tiene de height 95vh y el clip-path del
  polígono llega hasta 75vh. La direfencia es 20. 
  Por eso vamos a poner un padding de 25rem para que el titulo quede más abajo que esos 20, y luego
  un margin en negativo -20 para que el backgroun-color vaya hacia arriba y cubra toda la sección
  Ver en inspeccionar de chrome para entenderlo mejor!!*/
.feature-section {
  padding: 20rem 0;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/nat-4.jpg);
  background-size: cover;
  margin-top: -10rem;
  transform: skewY(-7deg); }
  .feature-section > * {
    transform: skewY(7deg); }

/*explicación de los transform: con el skewY negativo distorcionamos hacia arriba el background. Luego
para que nuestras tarjetas no se distorcionen ponemos transform positito, así se enderezan.*/
.section-tours {
  background-color: #f7f7f7;
  padding: 25rem 0 15rem 0;
  margin-top: -10rem; }

.section-stories {
  padding: 15rem 0;
  position: relative;
  /*lo ponemos position relative por ser el parent de bg-video a quien hemos dado
  position:absolute. De este modo quedará el video encimado como si fuera un background*/ }
