@charset "UTF-8";
/********ANIMATIÓN del Título del header*************/
@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
    /*igual a -100px*/ }
  80% {
    transform: translateX(1rem);
    /*igual a 10px*/ }
  100% {
    opacity: 1;
    transform: translateX(0); } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
    /*igual a 100px*/ }
  80% {
    transform: translateX(-1rem);
    /*igual a -10px*/ }
  100% {
    opacity: 1;
    transform: translateX(0); } }

/*
  - La animación podemos hacerla con Transition y luego hoover. Pero en este caso vemos otro modo 
  con @keyframe, se le pone un nombre (identifier) y luego se especifica 0% (cuando comienza) 100% (cuando
  termina) desde donde hasta donde va la animación. 
  -En 0 ponemos opacity 0 para que el elemento no se vea, y en 100 ponemos opacity 1 para que sea visible.
  -Transform:translatex, es que se mueva en dirección el eje x (horizontalmente), si es número negativo se
  mueve de derecha a izq y si es positivo de izq a der. 
  -Ahora vamos al selector (en nuestro caso: .heading-primary-main y sub) que queremos animar y 
  colocamos animation-name y animation-duration
  - Otra properties de Animation es Delay:..s, para que la animación empiece después de x tiempo. Otra
  animation-iteration-count:nº, por ejemplo si ponemos 3, se repite 3 veces....etc
  - A veces la animación, sin que se sepa bien porqué, rebota (en mi caso no hace eso el browser), 
  para evitarlo en .heading-primary usamos backface-visibility:hidden; 
  es un truco no se sabe porqué funciona. 
  */
/*Animación del boton*/
@keyframes moveInButton {
  0% {
    opacity: 0;
    transform: translateY(3rem);
    /*igual a 30px*/ }
  100% {
    opacity: 1;
    transform: translateX(0); } }

/***********BASIC RESET******************/
*,
*::after,
*::before {
  margin: 0;
  padding: 0;
  box-sizing: inherit;
  /* box-sizing: border-box; esto lo vamos a colocar en el body para aprovechar el inherit keyword 
  en nuestra página web y es una mejor práctica poner acá inherit y en el body border-box*/ }

/*
- Arriba lo que hicimos fue usar el "univesal selector" para resetear los margenes y padding
que por defecto tendríamos según los browsers. Es un basic reset. Agregamos tb pseudo-classes.
- Box sizing es útil a la hora de calcular todo lo que es el tamaña de los elementos y querer
agregarle paddings y margins...etc.
*/
html {
  font-size: 62.5%; }

/* es un base element porque define lo que un rem debe ser - 
por eso no lo ponemos en la carpeta de typography
- root element. Así todas nuestras unidades rem hacen referencia a este root y se multiplicarían por 10
- No vamos a definir el font-size en px, porque eso impide al usuario modificar luego el tamaño de la
fuente con el browser. Lo que queremos es definirlo en porcentaje.
Si ponemos font-size 100% equivaldría a 16px, porque ese es el default value de los font-size.
Como queremos que sean 10px hacemos regla de tres simples 100*10/16 = 62.5%
Ahora el user va a poder zoom in and zoom out no solo el font-size sino tb la página en sí
- Nota: el viejo Internet expolorer no soporta rems
*/
body {
  box-sizing: border-box; }

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* font-size: 16px; antes de crear el root teníamos este font-size 
    que ahora sacamos para poner las demás unidades en rem*/
  line-height: 1.7;
  color: #777;
  padding: 3rem;
  /*antes habíamos puesto 30px. Ahora son 3rem que multiplicado por 10px del html es igual a 30px*/ }

/*
  - font-family, es de google fonts, cuyo link hay que agregar en el código html, head section.
  - font-weight, 400 es igual a normal (default), y 700 igual a bold
  - line-height, si ponemos un número significa que es lo que se va a multiplicar del font size
  (se pueden usar px, rem, %...etc)
  - Agregamos un padding en el body, lo que hace que todos los elementos de nuestra página ahora
  tengan el mismo, salvo lo reescribamos.
  */
.heading-primary {
  color: #fff;
  text-transform: uppercase;
  backface-visibility: hidden;
  /*es para que funcione mejor la animación*/
  margin-bottom: 6rem;
  /*es para que el button se separe del heading*/
  /*
    -usamos display block para que cada span esté uno debajo del otro, de lo contrario by default
    son un inline element y estarían uno al lado del otro
    -el font-weight lo especificamos porque por defecto h1 tiene bold, y se sobreescribe al que
    ya habíamos puesto en el body por estar el h1 luego del body. Así que volvemos a poner 400px
    para que no sea bold.
    - Aniation property, en el heading-primary-sub usé el shorthand (de animation-name, animation-duration,
    animation-timing-function. 
    */ }
  .heading-primary--main {
    display: block;
    font-size: 6rem;
    /* igual a 60px*/
    font-weight: 400;
    letter-spacing: 3.5rem;
    /*igual a 35px*/
    animation-name: moveInLeft;
    animation-duration: 1s;
    animation-timing-function: ease-out; }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    /*igual a 20px*/
    font-weight: 700;
    letter-spacing: 1.74rem;
    /*igual a 17.4px*/
    animation: moveInRight 1s ease-out; }

.heading-secondary {
  font-size: 3.5rem;
  text-transform: uppercase;
  font-weight: 700; }

/***********BUTTON************/
.btn {
  /*acá separo los selectors con comas, y tengo que poner primero el simple selector
    y luego los seudo-class
    - Acá vamos a hacer una animación más simple con Transition (en vez de con @keyframe). 
    Transition es el shorthand. "all" significa que queremos animar todas las propiedades de arriba, 
    usamos esto cuando no estamos seguros de cual animar o no queremos escribir todas las propiedades. 
    */
  /*
    - btn con seudo-class :link (es para darle estilo a los unvisited links) y :visited.
    - btn con seudo-class :hover (cuando nos posicionamos encima con el mouse), :active (cuando hagamos
    click sobre el botón)
    - transform:translateY, se moverá de arriba a abajo. Número negativo hace que vaya hacia arriba. 
    */
  /*****ANIMACION con seudo-element ::******/
  /*
  Animation-fill-mode hace que se mantenga en opacity:0 y se translate 30px como especificamos en el
  @keyframe recién cuando pase el tiempo del delay*/ }
  .btn, .btn:link, .btn:visited {
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    /*igual a 15px y 40px*/
    display: inline-block;
    border-radius: 10rem;
    /*igual a 100px*/
    transition: all 0.2s;
    position: relative;
    /*esto es para la animación con seudo-element*/
    font-size: 1.6rem;
    /*es igual a 16px*/ }
  .btn:hover {
    transform: translateY(-0.3rem);
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.4);
    /*
    Con esto hacemos que cuando hagamos hover aparezca el btn::after que especificamos arriba y de agrande
    en 1.5 veces su tamaño y que se ponga transparente (opacity)*/ }
    .btn:hover::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0; }
  .btn:active {
    transform: translateY(-0.1rem);
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.4); }
  .btn--white {
    background-color: #fff;
    color: #777;
    /*
    - La idea es crear otro botón igual pero que esté por detrás, por eso usamos este seudo-element
    - Siempre en los seudo-element tenemos que poner "content" aunque despues lo dejemos vacío y el display
    - display inline-block porque así tb es el display del btn.
    - heigth y width es el 100% del tamaño del btn, que sería como su parent.
    - Positioning absolute tiene que tener un reference, en nuestro caso no queremos que sea el header ni el
    body, sino el btn, entonces es ahí donde le pondremos positon:relative
    - z-indez negativo es para que este botón se vaya atrás
    */ }
    .btn--white::after {
      background-color: #fff; }
  .btn::after {
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 10rem;
    /*igual a 100px*/
    position: absolute;
    top: 0;
    left: 0;
    z-index: -1;
    transition: all 0.4s; }
  .btn--animated {
    animation: moveInButton 0.5s ease-out;
    animation-delay: 0.75s;
    animation-fill-mode: backwards; }

/***************HEADER*****************/
.header {
  height: 95vh;
  background-image: linear-gradient(to right bottom, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  clip-path: polygon(0% 0%, 100% 0%, 100% 75vh, 0% 100%);
  position: relative;
  /*
  -El header tiene una altura según el view port - no del 100% sino del 95%, para que siempre
  guarde esa dimensión.
  -Tiene una background image, y le ponemos antes de la url el linear gradient para que tenga
  como una veladura por encima. La dirección del gradient es de right to bottom y tiene dos 
  colores, de más claro a más oscuro. 
  - Cover, hace que siempre la imagen complete el contenedor. 
  - background-position, en nuestro caso pusimos top, hace que cuando agrandemos o achiquemos
  la página siempre se vea la parte de arriba de la imagen.
  - clip-path, me sirve para hacer figuras con los contenedores, imágenes.
  Por eso vemos el corte que tiene la imágen en el header. 
  La página https://bennettfeely.com/clippy/ te calcula cada lado para formar distintas figuras.
  - En CSS no podemos poner un hexagesimal color y después un opacity, sino rgba. Pero en SASS 
  sí. Entonces ponemos rgba y dentro nuestra variable más el grado de opacity.
  */
  /*es el div que contiene el logo.
    - Acá la position es absolute. Pero si vemos en el header class su position es relative. Esto
    hace un juego entre ambos elementos. Header es el parent del logo-box, y siendo su position
    relative ahora el absolute position del child en en relación a él y no al body. Ver esta
    página mejor explicado  
    https://css-tricks.com/absolute-positioning-inside-relative-positioning/
    */
  /*
    Sólo hace falta especificar el height y no el width, este lo pone el browser 
    */
  /*
    - Usamos transform:translate porque el positioning top y left lo mide desde los bordes
    del div y no hace que quede centrado, mientras que transform:translate mueve el div desde 
    el mismo, no desde su borde, es así que termina centrándose. Tb hace que sea responsive,
    y se mueva según el tamaño del browser.
    */ }
  .header__logo-box {
    position: absolute;
    top: 4rem;
    /*antes pusimos 40px. Ahora es 4 por 10px del html root element igual 40px*/
    left: 4rem;
    /*lo mismo*/ }
  .header__logo {
    height: 3.5rem;
    /* igual 35px*/ }
  .header__text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    /*es para alinear el button*/ }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem 0;
  margin-top: -20vh; }
